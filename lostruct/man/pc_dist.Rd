% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pc_dist.R
\name{pc_dist}
\alias{pc_dist}
\title{Find Matrix of Distances Between Matrices from Eigenvector/values}
\usage{
pc_dist(x, npc = attr(x, "npc"), w = 1, normalize = "L1", mc.cores = 1)
}
\arguments{
\item{x}{Matrix as output by eigen_windows(): one row per window, with entries (sum squares), (eigenvalues), (eigenvectors).}

\item{npc}{Number of PCs computed.}

\item{w}{A vector of weights corresponding to samples (of same length as an eigenvector).}

\item{normalize}{Normalize the matrices to have the same norm?  Can be "L1" (default), "L2", or FALSE.}

\item{mc.cores}{If this is greater than 1, parallel::mclapply will be used.}
}
\value{
A symmetric, numeric matrix with number of columns equal to the number of columns in eigen.win$values.
}
\description{
Given a matrix of sets of eigenvalues/vectors for a set of n symmetric matrices as output by eigen_windows(),
return the (n x n) matrix whose [i,j]th element is the Frobenius norm of the difference between the i-th and the j-th matrices,
as approximated by the given eigenvalues/vectors. The approximation is in pseudocode
     M = values[1] * outer(vectors[1],vectors[1]) + values[2] * outer(vectors[2],vectors[2]) + ...
If \code{normalize} is set, then the the matrices are normalized to have norm 1, so that in the definition of M,
\code{values} is replaced by \code{values/sqrt(sum(values))}.
}
\details{
The norm is also weighted by the weights \code{w}:
  dist(A,B) = sqrt( sum_{i,j}  w[i] * w[j] * ( A[i,j] - B[i,j] )^2 )
}
